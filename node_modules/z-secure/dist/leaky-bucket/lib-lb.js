"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('leaky-bucket');
class LeakyBucket {
    constructor({ capacity = 60, timeout, interval = 60000, store } = {}) {
        this.maxCapacity = 0;
        this.interval = 60000;
        this.timeout = 60000;
        this.refillRate = 0;
        // Express middleware
        this.rateLimitMiddleware = (req, res, next) => {
            this.throttle() // throttle can be customized with cost parameters if needed
                .then(() => {
                next(); // Proceed to the next middleware or route handler
            })
                .catch((err) => {
                res.status(429).json({ error: err.message }); // Handle errors if rate limit exceeded
            });
        };
        timeout = timeout ?? interval;
        this.queue = [];
        this.totalCost = 0;
        this.currentCapacity = capacity;
        this.capacity = capacity;
        this.lastRefill = null;
        this.setCapacity(capacity);
        this.setTimeout(timeout);
        this.setInterval(interval);
        this.store = store;
    }
    async throttle(cost = 1, append = true, isPause = false) {
        const maxCurrentCapacity = this.getCurrentMaxCapacity();
        // if (this.store) {
        //   console.log('Using store for rate limiting.');
        // } else {
        //   console.log('Using in-memory rate limiting.');
        // }
        if (append && this.totalCost + cost > maxCurrentCapacity) {
            log(`Rejecting item: max capacity exceeded.`);
            throw new Error(`Bucket overflow.`);
        }
        return new Promise((resolve, reject) => {
            const item = { resolve, reject, cost, isPause };
            this.totalCost += cost;
            if (append) {
                this.queue.push(item);
                log(`Added item with cost ${cost}`);
            }
            else {
                this.queue.unshift(item);
                log(`Added item with cost ${cost}`);
                this.cleanQueue();
            }
            this.startTimer();
        });
    }
    startTimer() {
        if (!this.timer && this.queue.length > 0) {
            const item = this.getFirstItem();
            if (!item)
                return;
            log(`Processing item with cost ${item.cost}`);
            this.refill();
            if (this.currentCapacity >= item.cost) {
                item.resolve();
                log(`Resolved item with cost ${item.cost}`);
                this.shiftQueue();
                this.pay(item.cost);
                this.startTimer();
            }
            else {
                const requiredDelta = item.cost - this.currentCapacity;
                const timeToDelta = (requiredDelta / this.refillRate) * 1000;
                log(`Waiting ${timeToDelta} ms to process next item`);
                this.timer = setTimeout(() => {
                    this.timer = undefined;
                    this.startTimer();
                }, timeToDelta);
            }
        }
    }
    shiftQueue() {
        this.queue.shift();
        if (this.queue.length === 0 && this.emptyPromiseResolver) {
            this.emptyPromiseResolver();
        }
    }
    async isEmpty() {
        if (!this.emptyPromiseResolver) {
            this.emptyPromise = new Promise((resolve) => {
                this.emptyPromiseResolver = () => {
                    this.emptyPromiseResolver = undefined;
                    this.emptyPromise = undefined;
                    resolve();
                };
            });
        }
        return this.emptyPromise;
    }
    end() {
        log(`Ending bucket`);
        this.stopTimer();
        this.clear();
    }
    clear() {
        log(`Clearing queue`);
        this.queue = [];
        this.totalCost = 0;
    }
    pay(cost) {
        log(`Paying ${cost}`);
        this.currentCapacity -= cost;
        this.totalCost -= cost;
        if (this.lastRefill === null) {
            this.lastRefill = Date.now();
        }
    }
    stopTimer() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = undefined;
        }
    }
    refill() {
        if (this.currentCapacity < this.capacity && this.lastRefill !== null) {
            const elapsed = (Date.now() - this.lastRefill) / 1000;
            const refillAmount = elapsed * this.refillRate;
            this.currentCapacity = Math.min(this.currentCapacity + refillAmount, this.capacity);
            log(`Refilled ${refillAmount}, new capacity: ${this.currentCapacity}`);
            if (this.currentCapacity >= this.capacity) {
                this.currentCapacity = this.capacity;
                this.lastRefill = null;
            }
            else {
                this.lastRefill = Date.now();
            }
        }
    }
    getCurrentMaxCapacity() {
        this.refill();
        return this.capacity;
    }
    cleanQueue() {
        const maxCapacity = this.getCurrentMaxCapacity();
        let currentCapacity = 0;
        const index = this.queue.findIndex((item) => {
            currentCapacity += item.cost;
            return currentCapacity > maxCapacity;
        });
        if (index >= 0) {
            this.queue.splice(index).forEach((item) => {
                if (!item.isPause) {
                    log(`Rejecting item with cost ${item.cost} due to queue overflow`);
                    item.reject(new Error(`Queue overflow`));
                    this.totalCost -= item.cost;
                }
            });
        }
    }
    getFirstItem() {
        return this.queue.length > 0 ? this.queue[0] : null;
    }
    pauseByCost(cost) {
        this.stopTimer();
        log(`Pausing bucket by cost ${cost}`);
        this.throttle(cost, false, true);
    }
    pause(seconds = 1) {
        this.drain();
        this.stopTimer();
        const cost = this.refillRate * seconds;
        log(`Pausing bucket for ${seconds} seconds`);
        this.pauseByCost(cost);
    }
    drain() {
        log(`Draining bucket: capacity reset to 0`);
        this.currentCapacity = 0;
        this.lastRefill = Date.now();
    }
    setTimeout(timeout) {
        this.timeout = timeout;
        this.updateVariables();
        return this;
    }
    setInterval(interval) {
        this.interval = interval;
        this.updateVariables();
        return this;
    }
    setCapacity(capacity) {
        this.capacity = capacity;
        this.maxCapacity = capacity;
        this.currentCapacity = capacity;
        this.updateVariables();
        return this;
    }
    updateVariables() {
        this.refillRate = this.capacity / (this.interval / 1000);
        log(`Updated refill rate: ${this.refillRate}`);
    }
}
exports.default = LeakyBucket;
