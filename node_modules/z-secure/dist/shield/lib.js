"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAttackDetected = isAttackDetected;
exports.detectMaliciousRequest = detectMaliciousRequest;
// src/algorithm/ArcjetShield.ts
const inMemoryStore_1 = __importDefault(require("./memory/inMemoryStore"));
const parseConfig_1 = require("../parseConfig");
const detection_patterns_1 = require("./detection-patterns");
function isAttackDetected(input, patterns) {
    console.log("isAttackDetected");
    console.log(input);
    function scanValues(values) {
        return values.some(value => {
            if (typeof value === 'string') {
                return patterns.some(pattern => pattern.test(value));
            }
            else if (typeof value === 'object' && value !== null) {
                // Recursively check nested objects or arrays
                return isAttackDetected(value, patterns);
            }
            else {
                return false;
            }
        });
    }
    return scanValues(Object.values(input));
}
function detectMaliciousRequest(req, options) {
    const attackTypes = [];
    // Check enabled attack detection options
    console.log(req.body);
    if (options.xss && isAttackDetected({ ...req.query, ...req.body, ...req.params }, detection_patterns_1.detectXSSPatterns)) {
        attackTypes.push("XSS");
    }
    if (options.sqlInjection && isAttackDetected({ ...req.query, ...req.body, ...req.params }, detection_patterns_1.detectSQLInjectionPatterns)) {
        console.log("SQL Injection detected");
        attackTypes.push("SQL Injection");
    }
    if (options.lfi && isAttackDetected({ ...req.query, ...req.body, ...req.params }, detection_patterns_1.detectLfiPatterns)) {
        attackTypes.push("LFI");
    }
    return {
        isSuspicious: attackTypes.length > 0,
        attackTypes,
    };
}
class ZShield {
    constructor(options = {}) {
        this.middleware = (0, parseConfig_1.handleAsyncErrors)(async (req, res, next) => {
            const clientIP = req.ip;
            console.log("middleware!!");
            console.log(clientIP);
            if (!clientIP) {
                res.status(403).json({ error: this.options.message });
                return;
            }
            // Check if the client is already blocked
            const isBlocked = await this.memoryStore.isBlocked(clientIP);
            if (isBlocked) {
                res.status(403).json({ error: this.options.message });
                return;
            }
            // Detect attack patterns
            const { isSuspicious, attackTypes } = detectMaliciousRequest(req, this.options);
            if (!isSuspicious) {
                console.log("not suspicious");
                next();
                return;
            }
            // Log detected attack types
            console.log(`Suspicious activity detected from ${clientIP}: ${attackTypes.join(", ")}`);
            // Increment suspicion score
            const currentScore = await this.memoryStore.increment(clientIP, this.blockDurationMs);
            if (currentScore >= this.suspicionThreshold) {
                res.status(403).json({
                    error: this.options.message,
                    detectedAttacks: attackTypes,
                });
                return;
            }
            next();
        });
        console.log("created!!");
        this.options = {
            message: "Access denied due to suspicious activity.",
            suspicionThreshold: 5,
            blockDurationMs: 60000,
            csrf: true,
            xss: true,
            sqlInjection: true,
            lfi: true,
            rfi: true,
            shellInjection: true,
            store: new inMemoryStore_1.default(),
            ...options,
        };
        this.memoryStore = this.options.store;
        this.suspicionThreshold = this.options.suspicionThreshold ?? 5;
        this.blockDurationMs = this.options.blockDurationMs ?? 60000;
    }
    async flushExpiredScores() {
        await this.memoryStore.flushExpired();
    }
}
exports.default = ZShield;
