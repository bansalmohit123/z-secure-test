"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const script_1 = require("./script");
class RedisShieldStore {
    constructor(options) {
        this.suspicionThreshold = 5;
        this.blockDurationMs = 60000;
        this.client = options.client;
        this.windowMs = options.windowMs ?? 60000; // Default to 1 minute
        this.resetExpiryOnChange = options.resetExpiryOnChange ?? false;
        this.suspicionThreshold = options.suspicionThreshold ?? 5;
        this.blockDurationMs = options.blockDurationMs ?? 60000;
    }
    async set(key, score, ttl) {
        const expiry = Date.now() + ttl;
        await this.client.hmset(key, 'score', score, 'expiry', expiry, 'isBlocked', 'false');
        await this.client.expire(key, ttl / 1000); // Set TTL for key
    }
    async get(key) {
        const value = await this.client.hmget(key, 'score', 'expiry', 'isBlocked');
        const [score, expiry, isBlocked] = value;
        if (!score || !expiry || Date.now() > parseInt(expiry, 10)) {
            return undefined;
        }
        return {
            score: parseInt(score, 10),
            expiry: parseInt(expiry, 10),
            isBlocked: isBlocked === 'true'
        };
    }
    async increment(key, ttl) {
        // Use Lua script to handle the increment and blocking logic
        const result = await this.client.evalsha(script_1.scripts.increment, 1, key, this.suspicionThreshold.toString(), this.blockDurationMs.toString(), ttl.toString());
        return parseInt(result, 10);
    }
    async delete(key) {
        await this.client.del(key);
    }
    async flushExpired() {
        // Use Lua script to delete expired keys
        const deletedCount = await this.client.evalsha(script_1.scripts.flushExpired, 0);
        console.log(`Deleted ${deletedCount} expired keys.`);
    }
    async isBlocked(key) {
        const value = await this.client.hget(key, 'isBlocked');
        return value === 'true';
    }
}
exports.default = RedisShieldStore;
